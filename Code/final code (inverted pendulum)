//This code only considers the angular velocity and angle 
#include <Wire.h>
#include "MPU6050.h"

MPU6050 mpu;

// ---------------- MOTOR PINS ----------------
#define ENA 9
#define IN1 6
#define IN2 7

#define ENB 10
#define IN3 4
#define IN4 5

// --------------- CONTROL GAINS ---------------
float Kp = 28.0;
float Kd = 1.8;

// --------- MPU OFFSETS (PASTE YOUR VALUES) ----------
void applyOffsets() {
  mpu.setXAccelOffset(-737);
  mpu.setYAccelOffset(144);
  mpu.setZAccelOffset(1618);
  mpu.setXGyroOffset(897);
  mpu.setYGyroOffset(-56);
  mpu.setZGyroOffset(-21);
}

// Upright reference
float angleOffset = 82.0;
float Ux = -0.11;
float Uy =  0.55;

int16_t ax, ay, az, gx, gy, gz;
float prevAngle = 0;
unsigned long lastTime = 0;

// ===================================================
void setup() {
  Serial.begin(115200);
  Wire.begin();
  mpu.initialize();
  applyOffsets();

  pinMode(ENA, OUTPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);

  pinMode(ENB, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);

  // Fast PWM (31kHz)
  TCCR1B = (TCCR1B & 0b11111000) | 0x01;

  lastTime = micros();
  Serial.println("INVERTED PENDULUM READY");
}

// ===================================================
float getAngle() {
  mpu.getMotion6(&ax,&ay,&az,&gx,&gy,&gz);

  float axg = ax / 16384.0;
  float ayg = ay / 16384.0;

  float dot = Ux*axg + Uy*ayg;
  float cross = Ux*ayg - Uy*axg;

  float theta = atan2(cross, dot) * 180.0 / PI;
  return theta - angleOffset;
}

// ===================================================
void driveMotor(int pwm) {
  pwm = constrain(pwm, -255, 255);

  // FIXED DIRECTION (your setup)
  pwm = -pwm;

  if (pwm > 0) {
    digitalWrite(IN1,HIGH); digitalWrite(IN2,LOW);
    digitalWrite(IN3,HIGH); digitalWrite(IN4,LOW);
  } else {
    digitalWrite(IN1,LOW); digitalWrite(IN2,HIGH);
    digitalWrite(IN3,LOW); digitalWrite(IN4,HIGH);
  }

  analogWrite(ENA, abs(pwm));
  analogWrite(ENB, abs(pwm));
}

// ===================================================
void loop() {

  unsigned long now = micros();
  float dt = (now - lastTime) * 1e-6;
  lastTime = now;

  float angle = getAngle();
  float angleRate = (angle - prevAngle) / dt;
  prevAngle = angle;

  float control = Kp * angle + Kd * angleRate;
  control = constrain(control, -255, 255);

  driveMotor(control);

  Serial.print("Angle: ");
  Serial.print(angle);
  Serial.print("  PWM: ");
  Serial.println(control);
}
